// This file contains test utilities for setting up and managing test environments.

use async_graphql::{EmptySubscription, Schema};
use sqlx::{PgPool, postgres::PgPoolOptions};
use std::env;

// Initialize test database connection
// Uses TEST_DATABASE_URL environment variable if set, otherwise defaults to test database
pub async fn init_test_db() -> Result<PgPool, sqlx::Error> {
    let database_url = env::var("TEST_DATABASE_URL")
        .or_else(|_| env::var("DATABASE_URL"))
        .expect("TEST_DATABASE_URL or DATABASE_URL must be set");

    let pool = PgPoolOptions::new()
        .max_connections(5)
        .connect(&database_url)
        .await?;

    Ok(pool)
}

// Setup test database schema
// Creates tables and necessary schema elements for testing
pub async fn setup_test_schema(pool: &PgPool) -> Result<(), sqlx::Error> {
    // Force drop tables and sequences, ignoring errors
    let _ = sqlx::query("DROP TABLE IF EXISTS posts CASCADE")
        .execute(pool)
        .await;

    let _ = sqlx::query("DROP TABLE IF EXISTS users CASCADE")
        .execute(pool)
        .await;

    // Drop sequences explicitly
    let _ = sqlx::query("DROP SEQUENCE IF EXISTS users_id_seq CASCADE")
        .execute(pool)
        .await;

    let _ = sqlx::query("DROP SEQUENCE IF EXISTS posts_id_seq CASCADE")
        .execute(pool)
        .await;

    // Wait for locks to clear
    tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;

    sqlx::query(
        r#"
        CREATE TABLE users (
            id SERIAL PRIMARY KEY,
            name VARCHAR(255),
            age INTEGER,
            email VARCHAR(255),
            phone VARCHAR(50),
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        )
        "#,
    )
    .execute(pool)
    .await?;

    sqlx::query(
        r#"
        CREATE TABLE posts (
            id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            user_id INT REFERENCES users(id) ON DELETE CASCADE,
            title VARCHAR(255) NOT NULL,
            content TEXT,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        )
        "#,
    )
    .execute(pool)
    .await?;

    sqlx::query(
        r#"
        CREATE OR REPLACE FUNCTION set_updated_at() RETURNS TRIGGER AS $$
        BEGIN NEW.updated_at = CURRENT_TIMESTAMP; RETURN NEW; END;
        $$ LANGUAGE plpgsql
        "#,
    )
    .execute(pool)
    .await?;

    let _ = sqlx::query("DROP TRIGGER IF EXISTS update_users_updated_at ON users")
        .execute(pool)
        .await;

    let _ = sqlx::query(
        r#"
        CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
            FOR EACH ROW EXECUTE FUNCTION set_updated_at()
        "#,
    )
    .execute(pool)
    .await;

    let _ = sqlx::query("DROP TRIGGER IF EXISTS update_posts_updated_at ON posts")
        .execute(pool)
        .await;

    let _ = sqlx::query(
        r#"
        CREATE TRIGGER update_posts_updated_at BEFORE UPDATE ON posts
            FOR EACH ROW EXECUTE FUNCTION set_updated_at()
        "#,
    )
    .execute(pool)
    .await;

    Ok(())
}

// Clean test database
// Removes all data from tables before each test
pub async fn clean_test_db(pool: &PgPool) -> Result<(), sqlx::Error> {
    sqlx::query("DELETE FROM posts").execute(pool).await?;

    sqlx::query("DELETE FROM users").execute(pool).await?;

    Ok(())
}

// Seed test data
// Inserts sample users and posts for testing
pub async fn seed_test_data(pool: &PgPool) -> Result<(), sqlx::Error> {
    sqlx::query(
        r#"
        INSERT INTO users (id, name, age, email, phone) VALUES
            (1, 'Test User 1', 25, 'test1@example.com', '111-111-1111'),
            (2, 'Test User 2', 30, 'test2@example.com', '222-222-2222'),
            (3, 'Test User 3', 35, 'test3@example.com', '333-333-3333')
        "#,
    )
    .execute(pool)
    .await?;

    sqlx::query(
        r#"
        INSERT INTO posts (id, user_id, title, content) VALUES
            (1, 1, 'Test Post 1', 'Content for post 1'),
            (2, 1, 'Test Post 2', 'Content for post 2'),
            (3, 2, 'Test Post 3', 'Content for post 3')
        "#,
    )
    .execute(pool)
    .await?;

    // Advance sequences after inserting explicit IDs
    // This ensures next auto-generated IDs don't conflict
    sqlx::query("SELECT setval('users_id_seq', (SELECT MAX(id) FROM users), true)")
        .execute(pool)
        .await?;

    sqlx::query("SELECT setval('posts_id_seq', (SELECT MAX(id) FROM posts), true)")
        .execute(pool)
        .await?;

    Ok(())
}

// Reset sequences after cleanup
pub async fn reset_sequences(pool: &PgPool) -> Result<(), sqlx::Error> {
    sqlx::query("SELECT setval('users_id_seq', 1, false)")
        .execute(pool)
        .await?;

    sqlx::query("SELECT setval('posts_id_seq', 1, false)")
        .execute(pool)
        .await?;

    Ok(())
}

// Print database state for debugging
// Shows all users and posts in the database
#[allow(dead_code)]
pub async fn print_db_state(pool: &PgPool) -> Result<(), sqlx::Error> {
    println!("\n=== DATABASE STATE ===");

    let users = sqlx::query_as::<_, (i32, Option<String>, Option<i32>, Option<String>)>(
        "SELECT id, name, age, email FROM users ORDER BY id",
    )
    .fetch_all(pool)
    .await?;

    println!("\nUsers:");
    if users.is_empty() {
        println!("  (empty)");
    } else {
        for user in &users {
            println!(
                "  ID: {}, Name: {:?}, Age: {:?}, Email: {:?}",
                user.0, user.1, user.2, user.3
            );
        }
    }

    let posts = sqlx::query_as::<_, (i32, Option<i32>, Option<String>, Option<String>)>(
        "SELECT id, user_id, title, content FROM posts ORDER BY id",
    )
    .fetch_all(pool)
    .await?;

    println!("\nPosts:");
    if posts.is_empty() {
        println!("  (empty)");
    } else {
        for post in &posts {
            println!(
                "  ID: {}, User ID: {:?}, Title: {:?}, Content: {:?}",
                post.0, post.1, post.2, post.3
            );
        }
    }

    println!("=====================\n");
    Ok(())
}

// Setup function run before each test
// Each test gets a fresh database schema
pub async fn setup() -> PgPool {
    let pool = init_test_db()
        .await
        .expect("Failed to initialize test database");

    let mut retries = 0;
    loop {
        match setup_test_schema(&pool).await {
            Ok(_) => break,
            Err(e) => {
                retries += 1;
                if retries > 5 {
                    panic!("Failed to setup test schema after 5 retries: {}", e);
                }
                tokio::time::sleep(tokio::time::Duration::from_millis(100 * retries)).await;
            }
        }
    }

    clean_test_db(&pool)
        .await
        .expect("Failed to clean test database");
    reset_sequences(&pool)
        .await
        .expect("Failed to reset sequences");
    pool
}

// Helper function to build GraphQL schema
// Note: This requires resolvers module to be included in the test file
pub fn build_schema<Query, Mutation>(
    pool: PgPool,
    query: Query,
    mutation: Mutation,
) -> Schema<Query, Mutation, EmptySubscription>
where
    Query: async_graphql::ObjectType + Send + Sync + 'static,
    Mutation: async_graphql::ObjectType + Send + Sync + 'static,
{
    Schema::build(query, mutation, EmptySubscription)
        .data(pool)
        .finish()
}
